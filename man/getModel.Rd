% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getModel.R
\name{getModel}
\alias{getModel}
\title{Smoothed Quantile Regression with Group-Lasso Shrinkage (Stan)}
\usage{
getModel(
  y,
  taus,
  H,
  w,
  X = NULL,
  offset = NULL,
  alpha = 0.75,
  eps_w = 0.001,
  c_sigma = 1,
  penalty_c = 10,
  T_rel = 0.1,
  lambda_lasso2_a = 1,
  lambda_lasso2_b = 1,
  log_flag = 0,
  jittering = 0,
  chains = 1,
  iter = 1500,
  warmup = 500,
  control = NULL,
  seed = 123
)
}
\arguments{
\item{y}{Numeric vector of responses of length \eqn{n}.}

\item{taus}{Numeric vector of target quantile levels in \eqn{(0,1)}, length \eqn{m}.}

\item{H}{Numeric matrix \eqn{n \times r} of structured predictors for group-lasso
coefficients \eqn{\gamma}. If \eqn{r = 0}, pass a zero-column matrix.}

\item{w}{Integer \eqn{\ge 1}. Creates an intercept-like column \code{X0} with the
first \code{w} entries set to 1 and the rest 0 (e.g., a pre-period indicator),
which is then included in \code{X}.}

\item{X}{Optional numeric matrix \eqn{n \times p_x} of additional predictors.
If supplied, \code{X0} (defined by \code{w}) is prepended as the first column.
If \code{NULL} (default), \code{X} consists only of \code{X0}.}

\item{offset}{Optional numeric vector of length \eqn{n} added to the linear predictor.
Defaults to 0.}

\item{alpha, eps_w}{Reserved for future adaptive LASSO weights; currently unused
(weight construction code is commented out).}

\item{c_sigma}{Nonnegative scalar controlling the (currently disabled) per-quantile
scale prior; kept for compatibility.}

\item{penalty_c}{Positive scalar weight for the non-crossing penalty (larger is stricter).}

\item{T_rel}{Positive scalar “smoothing temperature” (dimensionless). The actual
smoothing scale is \code{base_scale * T_rel}, where \code{base_scale = sd(y)}.}

\item{lambda_lasso2_a, lambda_lasso2_b}{Positive shape/rate hyperparameters for the
global LASSO rate \eqn{\lambda}.}

\item{log_flag}{Integer \code{0/1}. If 1, fit on \code{log(y)} (with optional jitter)
and include Jacobian.}

\item{jittering}{Integer \code{0/1}. If 1, add \eqn{u \sim \mathrm{Beta}(1,1)} to \eqn{y}
(or inside the log if \code{log_flag = 1}) to mitigate ties / boundary issues.}

\item{chains}{Number of MCMC chains (passed to \code{rstan::sampling()}).}

\item{iter}{Total iterations per chain.}

\item{warmup}{Warmup iterations per chain.}

\item{control}{Optional list passed to \code{rstan::sampling()} (e.g., \code{adapt\_delta}).}

\item{seed}{RNG seed.}
}
\value{
An object of class \code{rstan::stanfit} containing posterior draws for
  \eqn{\mu}, \eqn{\beta}, \eqn{\gamma}, \eqn{\tau^{(rw)}}, \eqn{\lambda}, group variances,
  and other latent quantities used in the smoothed score.
}
\description{
Fits a multi-quantile (\eqn{m}) regression model where the conditional
quantile function is modeled as a latent random walk in time (or index)
with optional fixed effects \eqn{X} and structured effects \eqn{H}.
The \eqn{H}-coefficients are shrunk via a **grouped Bayesian LASSO**
(column-wise sharing across quantiles), and adjacent quantiles are softly
penalized to discourage crossings. The likelihood is optimized using a
**smoothed score** (logit-smoothed indicator) with temperature
\code{T_rel * base_scale}. The model is implemented in Stan and estimated
via MCMC using \strong{rstan}.
}
\details{
Internally, \code{H} is standardized (column-wise) and, if \code{p > 0}, first orthogonalized
against the columns of \code{X} to reduce competition. The Gram matrix of
\code{Z = [X | H]} is computed once for scoring, with a tiny ridge for numerical stability.

The function constructs a \code{stan\_model} from the embedded \code{stan\_code} string and
then runs \code{rstan::sampling()}. By default, only the group-LASSO hierarchy is active; the
element-wise adaptive-LASSO section is present but commented out in the Stan program.
}
\section{Model (high level)}{

\describe{
  \item{Data & design}{
    \itemize{
      \item \eqn{y_i} is optionally jittered (\code{u ~ Beta(1,1)}) and/or log-transformed.
      \item Combined linear predictor \eqn{\eta_{qi} = \mu_{q,i} + x_i^\top \beta_q + h_i^\top \gamma_q + \mathrm{offset}_i}.
      \item \eqn{\mu_{q,\cdot}} is a random walk per quantile: \eqn{\mu_{q,t} = \mu_{q,t-1} + \tau^{(rw)}_q z_{q,t-1}}.
    }
  }
  \item{Score objective}{
    Uses the logit-smoothed check-function derivative
    \eqn{\psi_{qi} = \tau_q - \mathrm{logit}^{-1}(-r_{qi}/(T_{\text{rel}} \cdot \text{base\_scale}))}
    with a quadratic form based on the quantile kernel \eqn{Q} and the Gram of \eqn{[X|H]}.
  }
  \item{Shrinkage on \eqn{\gamma}}{
    Column-wise grouped Bayesian LASSO:
    \eqn{\gamma_{qj} \sim \mathcal{N}(0, \sqrt{\tau_{\gamma,j}})},\quad
    \eqn{\tau_{\gamma,j} \sim \mathrm{Gamma}((m+1)/2,\ 0.5\,\lambda)},\quad
    \eqn{\lambda \sim \mathrm{Gamma}(\texttt{lambda\_lasso2\_a},\ \texttt{lambda\_lasso2\_b})}.
  }
  \item{Non-crossing penalty}{
    Adds an L1 hinge on the finite-difference derivative in \eqn{\tau},
    scaled by \code{penalty_c}.
  }
  \item{Optional transforms}{
    \code{jittering = 1} adds \eqn{u \sim \mathrm{Beta}(1,1)} to \eqn{y};
    \code{log\_flag = 1} fits the model on \eqn{\log(y + u)} and includes the Jacobian.
  }
}
}

\section{Convergence & diagnostics}{

Inspect R-hat, effective sample sizes, and divergences (increase \code{adapt\_delta}
and/or \code{iter} as needed). Because the likelihood is based on a smoothed score,
\code{T_rel} can materially affect mixing and sharpness of the posterior.
}

\examples{
\dontrun{
  set.seed(1)
  n   <- 100
  m   <- 3
  tau <- c(0.25, 0.5, 0.75)

  # Design
  w <- 20
  X <- cbind(rnorm(n))          # one extra covariate (X0 is added automatically)
  H <- cbind(rnorm(n), rnorm(n))# two structured columns for group-lasso
  off <- rep(0, n)

  # Data (toy)
  f  <- 0.3 * (1:n)/n + 0.5 * X[,1] - 0.7 * H[,1] + 0.2 * H[,2]
  y  <- f + rnorm(n, 0, 0.3)

  fit <- getModel(
    y = y, taus = tau, H = H, w = w, X = X, offset = off,
    chains = 2, iter = 1000, warmup = 500, seed = 123
  )

  print(fit, pars = c("lambda_lasso2", "tau_gamma_group"))
  # posterior summaries for gamma (H-coefficients) by quantile:
  # rstan::summary(fit, pars = "gamma")$summary
}

}
\seealso{
\code{\link[rstan]{sampling}}, \code{\link[rstan]{stan_model}}
}
